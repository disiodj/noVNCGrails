{"version":3,"sources":["deflate.js"],"names":["Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","strm","errorCode","msg","rank","f","zero","buf","len","length","flush_pending","s","state","pending","avail_out","utils","arraySet","output","pending_buf","pending_out","next_out","total_out","flush_block_only","last","trees","_tr_flush_block","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","window","wmask","w_mask","prev","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","n","m","more","str","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","_tr_tally","max_lazy_match","last_lit","deflate_slow","max_insert","prev_match","strategy","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","level","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","dyn_ltree","Buf16","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","deflateResetKeep","data_type","_tr_init","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","Buf8","deflateInit","deflate","old_flush","beg","val","text","hcrc","extra","name","comment","time","os","header","level_flags","charCodeAt","bstate","_tr_align","_tr_stored_block","deflateEnd","deflateSetDictionary","dictionary","dictLength","avail","next","tmpDict","deflateInfo"],"mappings":"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","sourcesContent":["import * as utils from \"../utils/common.js\";\r\nimport * as trees from \"./trees.js\";\r\nimport adler32 from \"./adler32.js\";\r\nimport crc32 from \"./crc32.js\";\r\nimport msg from \"./messages.js\";\r\n\r\n/* Public constants ==========================================================*/\r\n/* ===========================================================================*/\r\n\r\n\r\n/* Allowed flush values; see deflate() and inflate() below for details */\r\nexport const Z_NO_FLUSH      = 0;\r\nexport const Z_PARTIAL_FLUSH = 1;\r\n//export const Z_SYNC_FLUSH    = 2;\r\nexport const Z_FULL_FLUSH    = 3;\r\nexport const Z_FINISH        = 4;\r\nexport const Z_BLOCK         = 5;\r\n//export const Z_TREES         = 6;\r\n\r\n\r\n/* Return codes for the compression/decompression functions. Negative values\r\n * are errors, positive values are used for special but normal events.\r\n */\r\nexport const Z_OK            = 0;\r\nexport const Z_STREAM_END    = 1;\r\n//export const Z_NEED_DICT     = 2;\r\n//export const Z_ERRNO         = -1;\r\nexport const Z_STREAM_ERROR  = -2;\r\nexport const Z_DATA_ERROR    = -3;\r\n//export const Z_MEM_ERROR     = -4;\r\nexport const Z_BUF_ERROR     = -5;\r\n//export const Z_VERSION_ERROR = -6;\r\n\r\n\r\n/* compression levels */\r\n//export const Z_NO_COMPRESSION      = 0;\r\n//export const Z_BEST_SPEED          = 1;\r\n//export const Z_BEST_COMPRESSION    = 9;\r\nexport const Z_DEFAULT_COMPRESSION = -1;\r\n\r\n\r\nexport const Z_FILTERED            = 1;\r\nexport const Z_HUFFMAN_ONLY        = 2;\r\nexport const Z_RLE                 = 3;\r\nexport const Z_FIXED               = 4;\r\nexport const Z_DEFAULT_STRATEGY    = 0;\r\n\r\n/* Possible values of the data_type field (though see inflate()) */\r\n//export const Z_BINARY              = 0;\r\n//export const Z_TEXT                = 1;\r\n//export const Z_ASCII               = 1; // = Z_TEXT\r\nexport const Z_UNKNOWN             = 2;\r\n\r\n\r\n/* The deflate compression method */\r\nexport const Z_DEFLATED  = 8;\r\n\r\n/*============================================================================*/\r\n\r\n\r\nvar MAX_MEM_LEVEL = 9;\r\n/* Maximum value for memLevel in deflateInit2 */\r\nvar MAX_WBITS = 15;\r\n/* 32K LZ77 window */\r\nvar DEF_MEM_LEVEL = 8;\r\n\r\n\r\nvar LENGTH_CODES  = 29;\r\n/* number of length codes, not counting the special END_BLOCK code */\r\nvar LITERALS      = 256;\r\n/* number of literal bytes 0..255 */\r\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\r\n/* number of Literal or Length codes, including the END_BLOCK code */\r\nvar D_CODES       = 30;\r\n/* number of distance codes */\r\nvar BL_CODES      = 19;\r\n/* number of codes used to transfer the bit lengths */\r\nvar HEAP_SIZE     = 2 * L_CODES + 1;\r\n/* maximum heap size */\r\nvar MAX_BITS  = 15;\r\n/* All codes must not exceed MAX_BITS bits */\r\n\r\nvar MIN_MATCH = 3;\r\nvar MAX_MATCH = 258;\r\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\r\n\r\nvar PRESET_DICT = 0x20;\r\n\r\nvar INIT_STATE = 42;\r\nvar EXTRA_STATE = 69;\r\nvar NAME_STATE = 73;\r\nvar COMMENT_STATE = 91;\r\nvar HCRC_STATE = 103;\r\nvar BUSY_STATE = 113;\r\nvar FINISH_STATE = 666;\r\n\r\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\r\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\r\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\r\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\r\n\r\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\r\n\r\nfunction err(strm, errorCode) {\r\n  strm.msg = msg[errorCode];\r\n  return errorCode;\r\n}\r\n\r\nfunction rank(f) {\r\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\r\n}\r\n\r\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\r\n\r\n\r\n/* =========================================================================\r\n * Flush as much pending output as possible. All deflate() output goes\r\n * through this function so some applications may wish to modify it\r\n * to avoid allocating a large strm->output buffer and copying into it.\r\n * (See also read_buf()).\r\n */\r\nfunction flush_pending(strm) {\r\n  var s = strm.state;\r\n\r\n  //_tr_flush_bits(s);\r\n  var len = s.pending;\r\n  if (len > strm.avail_out) {\r\n    len = strm.avail_out;\r\n  }\r\n  if (len === 0) { return; }\r\n\r\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\r\n  strm.next_out += len;\r\n  s.pending_out += len;\r\n  strm.total_out += len;\r\n  strm.avail_out -= len;\r\n  s.pending -= len;\r\n  if (s.pending === 0) {\r\n    s.pending_out = 0;\r\n  }\r\n}\r\n\r\n\r\nfunction flush_block_only(s, last) {\r\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\r\n  s.block_start = s.strstart;\r\n  flush_pending(s.strm);\r\n}\r\n\r\n\r\nfunction put_byte(s, b) {\r\n  s.pending_buf[s.pending++] = b;\r\n}\r\n\r\n\r\n/* =========================================================================\r\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\r\n * IN assertion: the stream state is correct and there is enough room in\r\n * pending_buf.\r\n */\r\nfunction putShortMSB(s, b) {\r\n//  put_byte(s, (Byte)(b >> 8));\r\n//  put_byte(s, (Byte)(b & 0xff));\r\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\r\n  s.pending_buf[s.pending++] = b & 0xff;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Read a new buffer from the current input stream, update the adler32\r\n * and total number of bytes read.  All deflate() input goes through\r\n * this function so some applications may wish to modify it to avoid\r\n * allocating a large strm->input buffer and copying from it.\r\n * (See also flush_pending()).\r\n */\r\nfunction read_buf(strm, buf, start, size) {\r\n  var len = strm.avail_in;\r\n\r\n  if (len > size) { len = size; }\r\n  if (len === 0) { return 0; }\r\n\r\n  strm.avail_in -= len;\r\n\r\n  // zmemcpy(buf, strm->next_in, len);\r\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\r\n  if (strm.state.wrap === 1) {\r\n    strm.adler = adler32(strm.adler, buf, len, start);\r\n  }\r\n\r\n  else if (strm.state.wrap === 2) {\r\n    strm.adler = crc32(strm.adler, buf, len, start);\r\n  }\r\n\r\n  strm.next_in += len;\r\n  strm.total_in += len;\r\n\r\n  return len;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Set match_start to the longest match starting at the given string and\r\n * return its length. Matches shorter or equal to prev_length are discarded,\r\n * in which case the result is equal to prev_length and match_start is\r\n * garbage.\r\n * IN assertions: cur_match is the head of the hash chain for the current\r\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\r\n * OUT assertion: the match length is not greater than s->lookahead.\r\n */\r\nfunction longest_match(s, cur_match) {\r\n  var chain_length = s.max_chain_length;      /* max hash chain length */\r\n  var scan = s.strstart; /* current string */\r\n  var match;                       /* matched string */\r\n  var len;                           /* length of current match */\r\n  var best_len = s.prev_length;              /* best match length so far */\r\n  var nice_match = s.nice_match;             /* stop if match long enough */\r\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\r\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\r\n\r\n  var _win = s.window; // shortcut\r\n\r\n  var wmask = s.w_mask;\r\n  var prev  = s.prev;\r\n\r\n  /* Stop when cur_match becomes <= limit. To simplify the code,\r\n   * we prevent matches with the string of window index 0.\r\n   */\r\n\r\n  var strend = s.strstart + MAX_MATCH;\r\n  var scan_end1  = _win[scan + best_len - 1];\r\n  var scan_end   = _win[scan + best_len];\r\n\r\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\r\n   * It is easy to get rid of this optimization if necessary.\r\n   */\r\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\r\n\r\n  /* Do not waste too much time if we already have a good match: */\r\n  if (s.prev_length >= s.good_match) {\r\n    chain_length >>= 2;\r\n  }\r\n  /* Do not look for matches beyond the end of the input. This is necessary\r\n   * to make deflate deterministic.\r\n   */\r\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\r\n\r\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\r\n\r\n  do {\r\n    // Assert(cur_match < s->strstart, \"no future\");\r\n    match = cur_match;\r\n\r\n    /* Skip to next match if the match length cannot increase\r\n     * or if the match length is less than 2.  Note that the checks below\r\n     * for insufficient lookahead only occur occasionally for performance\r\n     * reasons.  Therefore uninitialized memory will be accessed, and\r\n     * conditional jumps will be made that depend on those values.\r\n     * However the length of the match is limited to the lookahead, so\r\n     * the output of deflate is not affected by the uninitialized values.\r\n     */\r\n\r\n    if (_win[match + best_len]     !== scan_end  ||\r\n        _win[match + best_len - 1] !== scan_end1 ||\r\n        _win[match]                !== _win[scan] ||\r\n        _win[++match]              !== _win[scan + 1]) {\r\n      continue;\r\n    }\r\n\r\n    /* The check at best_len-1 can be removed because it will be made\r\n     * again later. (This heuristic is not always a win.)\r\n     * It is not necessary to compare scan[2] and match[2] since they\r\n     * are always equal when the other bytes match, given that\r\n     * the hash keys are equal and that HASH_BITS >= 8.\r\n     */\r\n    scan += 2;\r\n    match++;\r\n    // Assert(*scan == *match, \"match[2]?\");\r\n\r\n    /* We check for insufficient lookahead only every 8th comparison;\r\n     * the 256th check will be made at strstart+258.\r\n     */\r\n    do {\r\n      // Do nothing\r\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             scan < strend);\r\n\r\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\r\n\r\n    len = MAX_MATCH - (strend - scan);\r\n    scan = strend - MAX_MATCH;\r\n\r\n    if (len > best_len) {\r\n      s.match_start = cur_match;\r\n      best_len = len;\r\n      if (len >= nice_match) {\r\n        break;\r\n      }\r\n      scan_end1  = _win[scan + best_len - 1];\r\n      scan_end   = _win[scan + best_len];\r\n    }\r\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\r\n\r\n  if (best_len <= s.lookahead) {\r\n    return best_len;\r\n  }\r\n  return s.lookahead;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Fill the window when the lookahead becomes insufficient.\r\n * Updates strstart and lookahead.\r\n *\r\n * IN assertion: lookahead < MIN_LOOKAHEAD\r\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\r\n *    At least one byte has been read, or avail_in == 0; reads are\r\n *    performed for at least two bytes (required for the zip translate_eol\r\n *    option -- not supported here).\r\n */\r\nfunction fill_window(s) {\r\n  var _w_size = s.w_size;\r\n  var p, n, m, more, str;\r\n\r\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\r\n\r\n  do {\r\n    more = s.window_size - s.lookahead - s.strstart;\r\n\r\n    // JS ints have 32 bit, block below not needed\r\n    /* Deal with !@#$% 64K limit: */\r\n    //if (sizeof(int) <= 2) {\r\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\r\n    //        more = wsize;\r\n    //\r\n    //  } else if (more == (unsigned)(-1)) {\r\n    //        /* Very unlikely, but possible on 16 bit machine if\r\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\r\n    //         */\r\n    //        more--;\r\n    //    }\r\n    //}\r\n\r\n\r\n    /* If the window is almost full and there is insufficient lookahead,\r\n     * move the upper half to the lower one to make room in the upper half.\r\n     */\r\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\r\n\r\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\r\n      s.match_start -= _w_size;\r\n      s.strstart -= _w_size;\r\n      /* we now have strstart >= MAX_DIST */\r\n      s.block_start -= _w_size;\r\n\r\n      /* Slide the hash table (could be avoided with 32 bit values\r\n       at the expense of memory usage). We slide even when level == 0\r\n       to keep the hash table consistent if we switch back to level > 0\r\n       later. (Using level 0 permanently is not an optimal usage of\r\n       zlib, so we don't care about this pathological case.)\r\n       */\r\n\r\n      n = s.hash_size;\r\n      p = n;\r\n      do {\r\n        m = s.head[--p];\r\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\r\n      } while (--n);\r\n\r\n      n = _w_size;\r\n      p = n;\r\n      do {\r\n        m = s.prev[--p];\r\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\r\n        /* If n is not on any hash chain, prev[n] is garbage but\r\n         * its value will never be used.\r\n         */\r\n      } while (--n);\r\n\r\n      more += _w_size;\r\n    }\r\n    if (s.strm.avail_in === 0) {\r\n      break;\r\n    }\r\n\r\n    /* If there was no sliding:\r\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\r\n     *    more == window_size - lookahead - strstart\r\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\r\n     * => more >= window_size - 2*WSIZE + 2\r\n     * In the BIG_MEM or MMAP case (not yet supported),\r\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\r\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\r\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\r\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\r\n     */\r\n    //Assert(more >= 2, \"more < 2\");\r\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\r\n    s.lookahead += n;\r\n\r\n    /* Initialize the hash value now that we have some input: */\r\n    if (s.lookahead + s.insert >= MIN_MATCH) {\r\n      str = s.strstart - s.insert;\r\n      s.ins_h = s.window[str];\r\n\r\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\r\n//#if MIN_MATCH != 3\r\n//        Call update_hash() MIN_MATCH-3 more times\r\n//#endif\r\n      while (s.insert) {\r\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\r\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\r\n\r\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\r\n        s.head[s.ins_h] = str;\r\n        str++;\r\n        s.insert--;\r\n        if (s.lookahead + s.insert < MIN_MATCH) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\r\n     * but this is not important since only literal bytes will be emitted.\r\n     */\r\n\r\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\r\n\r\n  /* If the WIN_INIT bytes after the end of the current data have never been\r\n   * written, then zero those bytes in order to avoid memory check reports of\r\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\r\n   * the longest match routines.  Update the high water mark for the next\r\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\r\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\r\n   */\r\n//  if (s.high_water < s.window_size) {\r\n//    var curr = s.strstart + s.lookahead;\r\n//    var init = 0;\r\n//\r\n//    if (s.high_water < curr) {\r\n//      /* Previous high water mark below current data -- zero WIN_INIT\r\n//       * bytes or up to end of window, whichever is less.\r\n//       */\r\n//      init = s.window_size - curr;\r\n//      if (init > WIN_INIT)\r\n//        init = WIN_INIT;\r\n//      zmemzero(s->window + curr, (unsigned)init);\r\n//      s->high_water = curr + init;\r\n//    }\r\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\r\n//      /* High water mark at or above current data, but below current data\r\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\r\n//       * to end of window, whichever is less.\r\n//       */\r\n//      init = (ulg)curr + WIN_INIT - s->high_water;\r\n//      if (init > s->window_size - s->high_water)\r\n//        init = s->window_size - s->high_water;\r\n//      zmemzero(s->window + s->high_water, (unsigned)init);\r\n//      s->high_water += init;\r\n//    }\r\n//  }\r\n//\r\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\r\n//    \"not enough room for search\");\r\n}\r\n\r\n/* ===========================================================================\r\n * Copy without compression as much as possible from the input stream, return\r\n * the current block state.\r\n * This function does not insert new strings in the dictionary since\r\n * uncompressible data is probably not useful. This function is used\r\n * only for the level=0 compression option.\r\n * NOTE: this function should be optimized to avoid extra copying from\r\n * window to pending_buf.\r\n */\r\nfunction deflate_stored(s, flush) {\r\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\r\n   * to pending_buf_size, and each stored block has a 5 byte header:\r\n   */\r\n  var max_block_size = 0xffff;\r\n\r\n  if (max_block_size > s.pending_buf_size - 5) {\r\n    max_block_size = s.pending_buf_size - 5;\r\n  }\r\n\r\n  /* Copy as much as possible from input to output: */\r\n  for (;;) {\r\n    /* Fill the window as much as possible: */\r\n    if (s.lookahead <= 1) {\r\n\r\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\r\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\r\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\r\n//        s.block_start >= s.w_size)) {\r\n//        throw  new Error(\"slide too late\");\r\n//      }\r\n\r\n      fill_window(s);\r\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n\r\n      if (s.lookahead === 0) {\r\n        break;\r\n      }\r\n      /* flush the current block */\r\n    }\r\n    //Assert(s->block_start >= 0L, \"block gone\");\r\n//    if (s.block_start < 0) throw new Error(\"block gone\");\r\n\r\n    s.strstart += s.lookahead;\r\n    s.lookahead = 0;\r\n\r\n    /* Emit a stored block if pending_buf will be full: */\r\n    var max_start = s.block_start + max_block_size;\r\n\r\n    if (s.strstart === 0 || s.strstart >= max_start) {\r\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\r\n      s.lookahead = s.strstart - max_start;\r\n      s.strstart = max_start;\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n\r\n\r\n    }\r\n    /* Flush if we may have to slide, otherwise block_start may become\r\n     * negative and the data will be gone:\r\n     */\r\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n\r\n  s.insert = 0;\r\n\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n\r\n  if (s.strstart > s.block_start) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n\r\n  return BS_NEED_MORE;\r\n}\r\n\r\n/* ===========================================================================\r\n * Compress as much as possible from the input stream, return the current\r\n * block state.\r\n * This function does not perform lazy evaluation of matches and inserts\r\n * new strings in the dictionary only for unmatched strings or for short\r\n * matches. It is used only for the fast compression options.\r\n */\r\nfunction deflate_fast(s, flush) {\r\n  var hash_head;        /* head of the hash chain */\r\n  var bflush;           /* set if current block must be flushed */\r\n\r\n  for (;;) {\r\n    /* Make sure that we always have enough lookahead, except\r\n     * at the end of the input file. We need MAX_MATCH bytes\r\n     * for the next match, plus MIN_MATCH bytes to insert the\r\n     * string following the next match.\r\n     */\r\n    if (s.lookahead < MIN_LOOKAHEAD) {\r\n      fill_window(s);\r\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      if (s.lookahead === 0) {\r\n        break; /* flush the current block */\r\n      }\r\n    }\r\n\r\n    /* Insert the string window[strstart .. strstart+2] in the\r\n     * dictionary, and set hash_head to the head of the hash chain:\r\n     */\r\n    hash_head = 0/*NIL*/;\r\n    if (s.lookahead >= MIN_MATCH) {\r\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n      s.head[s.ins_h] = s.strstart;\r\n      /***/\r\n    }\r\n\r\n    /* Find the longest match, discarding those <= prev_length.\r\n     * At this point we have always match_length < MIN_MATCH\r\n     */\r\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\r\n      /* To simplify the code, we prevent matches with the string\r\n       * of window index 0 (in particular we have to avoid a match\r\n       * of the string with itself at the start of the input file).\r\n       */\r\n      s.match_length = longest_match(s, hash_head);\r\n      /* longest_match() sets match_start */\r\n    }\r\n    if (s.match_length >= MIN_MATCH) {\r\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\r\n\r\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\r\n                     s.match_length - MIN_MATCH, bflush); ***/\r\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\r\n\r\n      s.lookahead -= s.match_length;\r\n\r\n      /* Insert new strings in the hash table only if the match length\r\n       * is not too large. This saves time but degrades compression.\r\n       */\r\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\r\n        s.match_length--; /* string at strstart already in table */\r\n        do {\r\n          s.strstart++;\r\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n          s.head[s.ins_h] = s.strstart;\r\n          /***/\r\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n           * always MIN_MATCH bytes ahead.\r\n           */\r\n        } while (--s.match_length !== 0);\r\n        s.strstart++;\r\n      } else\r\n      {\r\n        s.strstart += s.match_length;\r\n        s.match_length = 0;\r\n        s.ins_h = s.window[s.strstart];\r\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\r\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\r\n\r\n//#if MIN_MATCH != 3\r\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\r\n//#endif\r\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\r\n         * matter since it will be recomputed at next deflate call.\r\n         */\r\n      }\r\n    } else {\r\n      /* No match, output a literal byte */\r\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\r\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\r\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\r\n\r\n      s.lookahead--;\r\n      s.strstart++;\r\n    }\r\n    if (bflush) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n/* ===========================================================================\r\n * Same as above, but achieves better compression. We use a lazy\r\n * evaluation for matches: a match is finally adopted only if there is\r\n * no better match at the next window position.\r\n */\r\nfunction deflate_slow(s, flush) {\r\n  var hash_head;          /* head of hash chain */\r\n  var bflush;              /* set if current block must be flushed */\r\n\r\n  var max_insert;\r\n\r\n  /* Process the input block. */\r\n  for (;;) {\r\n    /* Make sure that we always have enough lookahead, except\r\n     * at the end of the input file. We need MAX_MATCH bytes\r\n     * for the next match, plus MIN_MATCH bytes to insert the\r\n     * string following the next match.\r\n     */\r\n    if (s.lookahead < MIN_LOOKAHEAD) {\r\n      fill_window(s);\r\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      if (s.lookahead === 0) { break; } /* flush the current block */\r\n    }\r\n\r\n    /* Insert the string window[strstart .. strstart+2] in the\r\n     * dictionary, and set hash_head to the head of the hash chain:\r\n     */\r\n    hash_head = 0/*NIL*/;\r\n    if (s.lookahead >= MIN_MATCH) {\r\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n      s.head[s.ins_h] = s.strstart;\r\n      /***/\r\n    }\r\n\r\n    /* Find the longest match, discarding those <= prev_length.\r\n     */\r\n    s.prev_length = s.match_length;\r\n    s.prev_match = s.match_start;\r\n    s.match_length = MIN_MATCH - 1;\r\n\r\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\r\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\r\n      /* To simplify the code, we prevent matches with the string\r\n       * of window index 0 (in particular we have to avoid a match\r\n       * of the string with itself at the start of the input file).\r\n       */\r\n      s.match_length = longest_match(s, hash_head);\r\n      /* longest_match() sets match_start */\r\n\r\n      if (s.match_length <= 5 &&\r\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\r\n\r\n        /* If prev_match is also MIN_MATCH, match_start is garbage\r\n         * but we will ignore the current match anyway.\r\n         */\r\n        s.match_length = MIN_MATCH - 1;\r\n      }\r\n    }\r\n    /* If there was a match at the previous step and the current\r\n     * match is not better, output the previous match:\r\n     */\r\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\r\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\r\n      /* Do not insert strings in hash table beyond this. */\r\n\r\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\r\n\r\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\r\n                     s.prev_length - MIN_MATCH, bflush);***/\r\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\r\n      /* Insert in hash table all strings up to the end of the match.\r\n       * strstart-1 and strstart are already inserted. If there is not\r\n       * enough lookahead, the last two strings are not inserted in\r\n       * the hash table.\r\n       */\r\n      s.lookahead -= s.prev_length - 1;\r\n      s.prev_length -= 2;\r\n      do {\r\n        if (++s.strstart <= max_insert) {\r\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n          s.head[s.ins_h] = s.strstart;\r\n          /***/\r\n        }\r\n      } while (--s.prev_length !== 0);\r\n      s.match_available = 0;\r\n      s.match_length = MIN_MATCH - 1;\r\n      s.strstart++;\r\n\r\n      if (bflush) {\r\n        /*** FLUSH_BLOCK(s, 0); ***/\r\n        flush_block_only(s, false);\r\n        if (s.strm.avail_out === 0) {\r\n          return BS_NEED_MORE;\r\n        }\r\n        /***/\r\n      }\r\n\r\n    } else if (s.match_available) {\r\n      /* If there was no match at the previous position, output a\r\n       * single literal. If there was a match but the current match\r\n       * is longer, truncate the previous match to a single literal.\r\n       */\r\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\r\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\r\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\r\n\r\n      if (bflush) {\r\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\r\n        flush_block_only(s, false);\r\n        /***/\r\n      }\r\n      s.strstart++;\r\n      s.lookahead--;\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n    } else {\r\n      /* There is no previous match to compare with, wait for\r\n       * the next step to decide.\r\n       */\r\n      s.match_available = 1;\r\n      s.strstart++;\r\n      s.lookahead--;\r\n    }\r\n  }\r\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\r\n  if (s.match_available) {\r\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\r\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\r\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\r\n\r\n    s.match_available = 0;\r\n  }\r\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\r\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\r\n * deflate switches away from Z_RLE.)\r\n */\r\nfunction deflate_rle(s, flush) {\r\n  var bflush;            /* set if current block must be flushed */\r\n  var prev;              /* byte at distance one to match */\r\n  var scan, strend;      /* scan goes up to strend for length of run */\r\n\r\n  var _win = s.window;\r\n\r\n  for (;;) {\r\n    /* Make sure that we always have enough lookahead, except\r\n     * at the end of the input file. We need MAX_MATCH bytes\r\n     * for the longest run, plus one for the unrolled loop.\r\n     */\r\n    if (s.lookahead <= MAX_MATCH) {\r\n      fill_window(s);\r\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      if (s.lookahead === 0) { break; } /* flush the current block */\r\n    }\r\n\r\n    /* See how many times the previous byte repeats */\r\n    s.match_length = 0;\r\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\r\n      scan = s.strstart - 1;\r\n      prev = _win[scan];\r\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\r\n        strend = s.strstart + MAX_MATCH;\r\n        do {\r\n          // Do nothing\r\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\r\n                 prev === _win[++scan] && prev === _win[++scan] &&\r\n                 prev === _win[++scan] && prev === _win[++scan] &&\r\n                 prev === _win[++scan] && prev === _win[++scan] &&\r\n                 scan < strend);\r\n        s.match_length = MAX_MATCH - (strend - scan);\r\n        if (s.match_length > s.lookahead) {\r\n          s.match_length = s.lookahead;\r\n        }\r\n      }\r\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\r\n    }\r\n\r\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\r\n    if (s.match_length >= MIN_MATCH) {\r\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\r\n\r\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\r\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\r\n\r\n      s.lookahead -= s.match_length;\r\n      s.strstart += s.match_length;\r\n      s.match_length = 0;\r\n    } else {\r\n      /* No match, output a literal byte */\r\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\r\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\r\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\r\n\r\n      s.lookahead--;\r\n      s.strstart++;\r\n    }\r\n    if (bflush) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n  s.insert = 0;\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n/* ===========================================================================\r\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\r\n * (It will be regenerated if this run of deflate switches away from Huffman.)\r\n */\r\nfunction deflate_huff(s, flush) {\r\n  var bflush;             /* set if current block must be flushed */\r\n\r\n  for (;;) {\r\n    /* Make sure that we have a literal to write. */\r\n    if (s.lookahead === 0) {\r\n      fill_window(s);\r\n      if (s.lookahead === 0) {\r\n        if (flush === Z_NO_FLUSH) {\r\n          return BS_NEED_MORE;\r\n        }\r\n        break;      /* flush the current block */\r\n      }\r\n    }\r\n\r\n    /* Output a literal byte */\r\n    s.match_length = 0;\r\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\r\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\r\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\r\n    s.lookahead--;\r\n    s.strstart++;\r\n    if (bflush) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n  s.insert = 0;\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\r\n * the desired pack level (0..9). The values given below have been tuned to\r\n * exclude worst case performance for pathological files. Better values may be\r\n * found for specific files.\r\n */\r\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\r\n  this.good_length = good_length;\r\n  this.max_lazy = max_lazy;\r\n  this.nice_length = nice_length;\r\n  this.max_chain = max_chain;\r\n  this.func = func;\r\n}\r\n\r\nvar configuration_table;\r\n\r\nconfiguration_table = [\r\n  /*      good lazy nice chain */\r\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\r\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\r\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\r\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\r\n\r\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\r\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\r\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\r\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\r\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\r\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\r\n];\r\n\r\n\r\n/* ===========================================================================\r\n * Initialize the \"longest match\" routines for a new zlib stream\r\n */\r\nfunction lm_init(s) {\r\n  s.window_size = 2 * s.w_size;\r\n\r\n  /*** CLEAR_HASH(s); ***/\r\n  zero(s.head); // Fill with NIL (= 0);\r\n\r\n  /* Set the default configuration parameters:\r\n   */\r\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\r\n  s.good_match = configuration_table[s.level].good_length;\r\n  s.nice_match = configuration_table[s.level].nice_length;\r\n  s.max_chain_length = configuration_table[s.level].max_chain;\r\n\r\n  s.strstart = 0;\r\n  s.block_start = 0;\r\n  s.lookahead = 0;\r\n  s.insert = 0;\r\n  s.match_length = s.prev_length = MIN_MATCH - 1;\r\n  s.match_available = 0;\r\n  s.ins_h = 0;\r\n}\r\n\r\n\r\nfunction DeflateState() {\r\n  this.strm = null;            /* pointer back to this zlib stream */\r\n  this.status = 0;            /* as the name implies */\r\n  this.pending_buf = null;      /* output still pending */\r\n  this.pending_buf_size = 0;  /* size of pending_buf */\r\n  this.pending_out = 0;       /* next pending byte to output to the stream */\r\n  this.pending = 0;           /* nb of bytes in the pending buffer */\r\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\r\n  this.gzhead = null;         /* gzip header information to write */\r\n  this.gzindex = 0;           /* where in extra, name, or comment */\r\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\r\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\r\n\r\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\r\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\r\n  this.w_mask = 0;  /* w_size - 1 */\r\n\r\n  this.window = null;\r\n  /* Sliding window. Input bytes are read into the second half of the window,\r\n   * and move to the first half later to keep a dictionary of at least wSize\r\n   * bytes. With this organization, matches are limited to a distance of\r\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\r\n   * performed with a length multiple of the block size.\r\n   */\r\n\r\n  this.window_size = 0;\r\n  /* Actual size of window: 2*wSize, except when the user input buffer\r\n   * is directly used as sliding window.\r\n   */\r\n\r\n  this.prev = null;\r\n  /* Link to older string with same hash index. To limit the size of this\r\n   * array to 64K, this link is maintained only for the last 32K strings.\r\n   * An index in this array is thus a window index modulo 32K.\r\n   */\r\n\r\n  this.head = null;   /* Heads of the hash chains or NIL. */\r\n\r\n  this.ins_h = 0;       /* hash index of string to be inserted */\r\n  this.hash_size = 0;   /* number of elements in hash table */\r\n  this.hash_bits = 0;   /* log2(hash_size) */\r\n  this.hash_mask = 0;   /* hash_size-1 */\r\n\r\n  this.hash_shift = 0;\r\n  /* Number of bits by which ins_h must be shifted at each input\r\n   * step. It must be such that after MIN_MATCH steps, the oldest\r\n   * byte no longer takes part in the hash key, that is:\r\n   *   hash_shift * MIN_MATCH >= hash_bits\r\n   */\r\n\r\n  this.block_start = 0;\r\n  /* Window position at the beginning of the current output block. Gets\r\n   * negative when the window is moved backwards.\r\n   */\r\n\r\n  this.match_length = 0;      /* length of best match */\r\n  this.prev_match = 0;        /* previous match */\r\n  this.match_available = 0;   /* set if previous match exists */\r\n  this.strstart = 0;          /* start of string to insert */\r\n  this.match_start = 0;       /* start of matching string */\r\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\r\n\r\n  this.prev_length = 0;\r\n  /* Length of the best match at previous step. Matches not greater than this\r\n   * are discarded. This is used in the lazy match evaluation.\r\n   */\r\n\r\n  this.max_chain_length = 0;\r\n  /* To speed up deflation, hash chains are never searched beyond this\r\n   * length.  A higher limit improves compression ratio but degrades the\r\n   * speed.\r\n   */\r\n\r\n  this.max_lazy_match = 0;\r\n  /* Attempt to find a better match only when the current match is strictly\r\n   * smaller than this value. This mechanism is used only for compression\r\n   * levels >= 4.\r\n   */\r\n  // That's alias to max_lazy_match, don't use directly\r\n  //this.max_insert_length = 0;\r\n  /* Insert new strings in the hash table only if the match length is not\r\n   * greater than this length. This saves time but degrades compression.\r\n   * max_insert_length is used only for compression levels <= 3.\r\n   */\r\n\r\n  this.level = 0;     /* compression level (1..9) */\r\n  this.strategy = 0;  /* favor or force Huffman coding*/\r\n\r\n  this.good_match = 0;\r\n  /* Use a faster search when the previous match is longer than this */\r\n\r\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\r\n\r\n              /* used by trees.c: */\r\n\r\n  /* Didn't use ct_data typedef below to suppress compiler warning */\r\n\r\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\r\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\r\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\r\n\r\n  // Use flat array of DOUBLE size, with interleaved fata,\r\n  // because JS does not support effective\r\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\r\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\r\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\r\n  zero(this.dyn_ltree);\r\n  zero(this.dyn_dtree);\r\n  zero(this.bl_tree);\r\n\r\n  this.l_desc   = null;         /* desc. for literal tree */\r\n  this.d_desc   = null;         /* desc. for distance tree */\r\n  this.bl_desc  = null;         /* desc. for bit length tree */\r\n\r\n  //ush bl_count[MAX_BITS+1];\r\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\r\n  /* number of codes at each bit length for an optimal tree */\r\n\r\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\r\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\r\n  zero(this.heap);\r\n\r\n  this.heap_len = 0;               /* number of elements in the heap */\r\n  this.heap_max = 0;               /* element of largest frequency */\r\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\r\n   * The same heap array is used to build all trees.\r\n   */\r\n\r\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\r\n  zero(this.depth);\r\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\r\n   */\r\n\r\n  this.l_buf = 0;          /* buffer index for literals or lengths */\r\n\r\n  this.lit_bufsize = 0;\r\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\r\n   * limiting lit_bufsize to 64K:\r\n   *   - frequencies can be kept in 16 bit counters\r\n   *   - if compression is not successful for the first block, all input\r\n   *     data is still in the window so we can still emit a stored block even\r\n   *     when input comes from standard input.  (This can also be done for\r\n   *     all blocks if lit_bufsize is not greater than 32K.)\r\n   *   - if compression is not successful for a file smaller than 64K, we can\r\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\r\n   *     This is applicable only for zip (not gzip or zlib).\r\n   *   - creating new Huffman trees less frequently may not provide fast\r\n   *     adaptation to changes in the input data statistics. (Take for\r\n   *     example a binary file with poorly compressible code followed by\r\n   *     a highly compressible string table.) Smaller buffer sizes give\r\n   *     fast adaptation but have of course the overhead of transmitting\r\n   *     trees more frequently.\r\n   *   - I can't count above 4\r\n   */\r\n\r\n  this.last_lit = 0;      /* running index in l_buf */\r\n\r\n  this.d_buf = 0;\r\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\r\n   * the same number of elements. To use different lengths, an extra flag\r\n   * array would be necessary.\r\n   */\r\n\r\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\r\n  this.static_len = 0;    /* bit length of current block with static trees */\r\n  this.matches = 0;       /* number of string matches in current block */\r\n  this.insert = 0;        /* bytes at end of window left to insert */\r\n\r\n\r\n  this.bi_buf = 0;\r\n  /* Output buffer. bits are inserted starting at the bottom (least\r\n   * significant bits).\r\n   */\r\n  this.bi_valid = 0;\r\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\r\n   * are always zero.\r\n   */\r\n\r\n  // Used for window memory init. We safely ignore it for JS. That makes\r\n  // sense only for pointers and memory check tools.\r\n  //this.high_water = 0;\r\n  /* High water mark offset in window for initialized bytes -- bytes above\r\n   * this are set to zero in order to avoid memory check warnings when\r\n   * longest match routines access bytes past the input.  This is then\r\n   * updated to the new high water mark.\r\n   */\r\n}\r\n\r\n\r\nfunction deflateResetKeep(strm) {\r\n  var s;\r\n\r\n  if (!strm || !strm.state) {\r\n    return err(strm, Z_STREAM_ERROR);\r\n  }\r\n\r\n  strm.total_in = strm.total_out = 0;\r\n  strm.data_type = Z_UNKNOWN;\r\n\r\n  s = strm.state;\r\n  s.pending = 0;\r\n  s.pending_out = 0;\r\n\r\n  if (s.wrap < 0) {\r\n    s.wrap = -s.wrap;\r\n    /* was made negative by deflate(..., Z_FINISH); */\r\n  }\r\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\r\n  strm.adler = (s.wrap === 2) ?\r\n    0  // crc32(0, Z_NULL, 0)\r\n  :\r\n    1; // adler32(0, Z_NULL, 0)\r\n  s.last_flush = Z_NO_FLUSH;\r\n  trees._tr_init(s);\r\n  return Z_OK;\r\n}\r\n\r\n\r\nfunction deflateReset(strm) {\r\n  var ret = deflateResetKeep(strm);\r\n  if (ret === Z_OK) {\r\n    lm_init(strm.state);\r\n  }\r\n  return ret;\r\n}\r\n\r\n\r\nfunction deflateSetHeader(strm, head) {\r\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\r\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\r\n  strm.state.gzhead = head;\r\n  return Z_OK;\r\n}\r\n\r\n\r\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\r\n  if (!strm) { // === Z_NULL\r\n    return Z_STREAM_ERROR;\r\n  }\r\n  var wrap = 1;\r\n\r\n  if (level === Z_DEFAULT_COMPRESSION) {\r\n    level = 6;\r\n  }\r\n\r\n  if (windowBits < 0) { /* suppress zlib wrapper */\r\n    wrap = 0;\r\n    windowBits = -windowBits;\r\n  }\r\n\r\n  else if (windowBits > 15) {\r\n    wrap = 2;           /* write gzip wrapper instead */\r\n    windowBits -= 16;\r\n  }\r\n\r\n\r\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\r\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\r\n    strategy < 0 || strategy > Z_FIXED) {\r\n    return err(strm, Z_STREAM_ERROR);\r\n  }\r\n\r\n\r\n  if (windowBits === 8) {\r\n    windowBits = 9;\r\n  }\r\n  /* until 256-byte window bug fixed */\r\n\r\n  var s = new DeflateState();\r\n\r\n  strm.state = s;\r\n  s.strm = strm;\r\n\r\n  s.wrap = wrap;\r\n  s.gzhead = null;\r\n  s.w_bits = windowBits;\r\n  s.w_size = 1 << s.w_bits;\r\n  s.w_mask = s.w_size - 1;\r\n\r\n  s.hash_bits = memLevel + 7;\r\n  s.hash_size = 1 << s.hash_bits;\r\n  s.hash_mask = s.hash_size - 1;\r\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\r\n\r\n  s.window = new utils.Buf8(s.w_size * 2);\r\n  s.head = new utils.Buf16(s.hash_size);\r\n  s.prev = new utils.Buf16(s.w_size);\r\n\r\n  // Don't need mem init magic for JS.\r\n  //s.high_water = 0;  /* nothing written to s->window yet */\r\n\r\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\r\n\r\n  s.pending_buf_size = s.lit_bufsize * 4;\r\n\r\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\r\n  //s->pending_buf = (uchf *) overlay;\r\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\r\n\r\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\r\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\r\n  s.d_buf = 1 * s.lit_bufsize;\r\n\r\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\r\n  s.l_buf = (1 + 2) * s.lit_bufsize;\r\n\r\n  s.level = level;\r\n  s.strategy = strategy;\r\n  s.method = method;\r\n\r\n  return deflateReset(strm);\r\n}\r\n\r\nfunction deflateInit(strm, level) {\r\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\r\n}\r\n\r\n\r\nfunction deflate(strm, flush) {\r\n  var old_flush, s;\r\n  var beg, val; // for gzip header write only\r\n\r\n  if (!strm || !strm.state ||\r\n    flush > Z_BLOCK || flush < 0) {\r\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\r\n  }\r\n\r\n  s = strm.state;\r\n\r\n  if (!strm.output ||\r\n      (!strm.input && strm.avail_in !== 0) ||\r\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\r\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\r\n  }\r\n\r\n  s.strm = strm; /* just in case */\r\n  old_flush = s.last_flush;\r\n  s.last_flush = flush;\r\n\r\n  /* Write the header */\r\n  if (s.status === INIT_STATE) {\r\n\r\n    if (s.wrap === 2) { // GZIP header\r\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\r\n      put_byte(s, 31);\r\n      put_byte(s, 139);\r\n      put_byte(s, 8);\r\n      if (!s.gzhead) { // s->gzhead == Z_NULL\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, s.level === 9 ? 2 :\r\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\r\n                     4 : 0));\r\n        put_byte(s, OS_CODE);\r\n        s.status = BUSY_STATE;\r\n      }\r\n      else {\r\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\r\n                    (s.gzhead.hcrc ? 2 : 0) +\r\n                    (!s.gzhead.extra ? 0 : 4) +\r\n                    (!s.gzhead.name ? 0 : 8) +\r\n                    (!s.gzhead.comment ? 0 : 16)\r\n                );\r\n        put_byte(s, s.gzhead.time & 0xff);\r\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\r\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\r\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\r\n        put_byte(s, s.level === 9 ? 2 :\r\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\r\n                     4 : 0));\r\n        put_byte(s, s.gzhead.os & 0xff);\r\n        if (s.gzhead.extra && s.gzhead.extra.length) {\r\n          put_byte(s, s.gzhead.extra.length & 0xff);\r\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\r\n        }\r\n        if (s.gzhead.hcrc) {\r\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\r\n        }\r\n        s.gzindex = 0;\r\n        s.status = EXTRA_STATE;\r\n      }\r\n    }\r\n    else // DEFLATE header\r\n    {\r\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\r\n      var level_flags = -1;\r\n\r\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\r\n        level_flags = 0;\r\n      } else if (s.level < 6) {\r\n        level_flags = 1;\r\n      } else if (s.level === 6) {\r\n        level_flags = 2;\r\n      } else {\r\n        level_flags = 3;\r\n      }\r\n      header |= (level_flags << 6);\r\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\r\n      header += 31 - (header % 31);\r\n\r\n      s.status = BUSY_STATE;\r\n      putShortMSB(s, header);\r\n\r\n      /* Save the adler32 of the preset dictionary: */\r\n      if (s.strstart !== 0) {\r\n        putShortMSB(s, strm.adler >>> 16);\r\n        putShortMSB(s, strm.adler & 0xffff);\r\n      }\r\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\r\n    }\r\n  }\r\n\r\n//#ifdef GZIP\r\n  if (s.status === EXTRA_STATE) {\r\n    if (s.gzhead.extra/* != Z_NULL*/) {\r\n      beg = s.pending;  /* start of bytes to update crc */\r\n\r\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\r\n        if (s.pending === s.pending_buf_size) {\r\n          if (s.gzhead.hcrc && s.pending > beg) {\r\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n          }\r\n          flush_pending(strm);\r\n          beg = s.pending;\r\n          if (s.pending === s.pending_buf_size) {\r\n            break;\r\n          }\r\n        }\r\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\r\n        s.gzindex++;\r\n      }\r\n      if (s.gzhead.hcrc && s.pending > beg) {\r\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n      }\r\n      if (s.gzindex === s.gzhead.extra.length) {\r\n        s.gzindex = 0;\r\n        s.status = NAME_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = NAME_STATE;\r\n    }\r\n  }\r\n  if (s.status === NAME_STATE) {\r\n    if (s.gzhead.name/* != Z_NULL*/) {\r\n      beg = s.pending;  /* start of bytes to update crc */\r\n      //int val;\r\n\r\n      do {\r\n        if (s.pending === s.pending_buf_size) {\r\n          if (s.gzhead.hcrc && s.pending > beg) {\r\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n          }\r\n          flush_pending(strm);\r\n          beg = s.pending;\r\n          if (s.pending === s.pending_buf_size) {\r\n            val = 1;\r\n            break;\r\n          }\r\n        }\r\n        // JS specific: little magic to add zero terminator to end of string\r\n        if (s.gzindex < s.gzhead.name.length) {\r\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\r\n        } else {\r\n          val = 0;\r\n        }\r\n        put_byte(s, val);\r\n      } while (val !== 0);\r\n\r\n      if (s.gzhead.hcrc && s.pending > beg) {\r\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n      }\r\n      if (val === 0) {\r\n        s.gzindex = 0;\r\n        s.status = COMMENT_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = COMMENT_STATE;\r\n    }\r\n  }\r\n  if (s.status === COMMENT_STATE) {\r\n    if (s.gzhead.comment/* != Z_NULL*/) {\r\n      beg = s.pending;  /* start of bytes to update crc */\r\n      //int val;\r\n\r\n      do {\r\n        if (s.pending === s.pending_buf_size) {\r\n          if (s.gzhead.hcrc && s.pending > beg) {\r\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n          }\r\n          flush_pending(strm);\r\n          beg = s.pending;\r\n          if (s.pending === s.pending_buf_size) {\r\n            val = 1;\r\n            break;\r\n          }\r\n        }\r\n        // JS specific: little magic to add zero terminator to end of string\r\n        if (s.gzindex < s.gzhead.comment.length) {\r\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\r\n        } else {\r\n          val = 0;\r\n        }\r\n        put_byte(s, val);\r\n      } while (val !== 0);\r\n\r\n      if (s.gzhead.hcrc && s.pending > beg) {\r\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n      }\r\n      if (val === 0) {\r\n        s.status = HCRC_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = HCRC_STATE;\r\n    }\r\n  }\r\n  if (s.status === HCRC_STATE) {\r\n    if (s.gzhead.hcrc) {\r\n      if (s.pending + 2 > s.pending_buf_size) {\r\n        flush_pending(strm);\r\n      }\r\n      if (s.pending + 2 <= s.pending_buf_size) {\r\n        put_byte(s, strm.adler & 0xff);\r\n        put_byte(s, (strm.adler >> 8) & 0xff);\r\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\r\n        s.status = BUSY_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = BUSY_STATE;\r\n    }\r\n  }\r\n//#endif\r\n\r\n  /* Flush as much pending output as possible */\r\n  if (s.pending !== 0) {\r\n    flush_pending(strm);\r\n    if (strm.avail_out === 0) {\r\n      /* Since avail_out is 0, deflate will be called again with\r\n       * more output space, but possibly with both pending and\r\n       * avail_in equal to zero. There won't be anything to do,\r\n       * but this is not an error situation so make sure we\r\n       * return OK instead of BUF_ERROR at next call of deflate:\r\n       */\r\n      s.last_flush = -1;\r\n      return Z_OK;\r\n    }\r\n\r\n    /* Make sure there is something to do and avoid duplicate consecutive\r\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\r\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\r\n     */\r\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\r\n    flush !== Z_FINISH) {\r\n    return err(strm, Z_BUF_ERROR);\r\n  }\r\n\r\n  /* User must not provide more input after the first FINISH: */\r\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\r\n    return err(strm, Z_BUF_ERROR);\r\n  }\r\n\r\n  /* Start a new block or continue the current one.\r\n   */\r\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\r\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\r\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\r\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\r\n        configuration_table[s.level].func(s, flush));\r\n\r\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\r\n      s.status = FINISH_STATE;\r\n    }\r\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\r\n      if (strm.avail_out === 0) {\r\n        s.last_flush = -1;\r\n        /* avoid BUF_ERROR next call, see above */\r\n      }\r\n      return Z_OK;\r\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\r\n       * of deflate should use the same flush parameter to make sure\r\n       * that the flush is complete. So we don't have to output an\r\n       * empty block here, this will be done at next call. This also\r\n       * ensures that for a very small output buffer, we emit at most\r\n       * one empty block.\r\n       */\r\n    }\r\n    if (bstate === BS_BLOCK_DONE) {\r\n      if (flush === Z_PARTIAL_FLUSH) {\r\n        trees._tr_align(s);\r\n      }\r\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\r\n\r\n        trees._tr_stored_block(s, 0, 0, false);\r\n        /* For a full flush, this empty block will be recognized\r\n         * as a special marker by inflate_sync().\r\n         */\r\n        if (flush === Z_FULL_FLUSH) {\r\n          /*** CLEAR_HASH(s); ***/             /* forget history */\r\n          zero(s.head); // Fill with NIL (= 0);\r\n\r\n          if (s.lookahead === 0) {\r\n            s.strstart = 0;\r\n            s.block_start = 0;\r\n            s.insert = 0;\r\n          }\r\n        }\r\n      }\r\n      flush_pending(strm);\r\n      if (strm.avail_out === 0) {\r\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\r\n        return Z_OK;\r\n      }\r\n    }\r\n  }\r\n  //Assert(strm->avail_out > 0, \"bug2\");\r\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\r\n\r\n  if (flush !== Z_FINISH) { return Z_OK; }\r\n  if (s.wrap <= 0) { return Z_STREAM_END; }\r\n\r\n  /* Write the trailer */\r\n  if (s.wrap === 2) {\r\n    put_byte(s, strm.adler & 0xff);\r\n    put_byte(s, (strm.adler >> 8) & 0xff);\r\n    put_byte(s, (strm.adler >> 16) & 0xff);\r\n    put_byte(s, (strm.adler >> 24) & 0xff);\r\n    put_byte(s, strm.total_in & 0xff);\r\n    put_byte(s, (strm.total_in >> 8) & 0xff);\r\n    put_byte(s, (strm.total_in >> 16) & 0xff);\r\n    put_byte(s, (strm.total_in >> 24) & 0xff);\r\n  }\r\n  else\r\n  {\r\n    putShortMSB(s, strm.adler >>> 16);\r\n    putShortMSB(s, strm.adler & 0xffff);\r\n  }\r\n\r\n  flush_pending(strm);\r\n  /* If avail_out is zero, the application will call deflate again\r\n   * to flush the rest.\r\n   */\r\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\r\n  /* write the trailer only once! */\r\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\r\n}\r\n\r\nfunction deflateEnd(strm) {\r\n  var status;\r\n\r\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\r\n    return Z_STREAM_ERROR;\r\n  }\r\n\r\n  status = strm.state.status;\r\n  if (status !== INIT_STATE &&\r\n    status !== EXTRA_STATE &&\r\n    status !== NAME_STATE &&\r\n    status !== COMMENT_STATE &&\r\n    status !== HCRC_STATE &&\r\n    status !== BUSY_STATE &&\r\n    status !== FINISH_STATE\r\n  ) {\r\n    return err(strm, Z_STREAM_ERROR);\r\n  }\r\n\r\n  strm.state = null;\r\n\r\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\r\n}\r\n\r\n\r\n/* =========================================================================\r\n * Initializes the compression dictionary from the given byte\r\n * sequence without producing any compressed output.\r\n */\r\nfunction deflateSetDictionary(strm, dictionary) {\r\n  var dictLength = dictionary.length;\r\n\r\n  var s;\r\n  var str, n;\r\n  var wrap;\r\n  var avail;\r\n  var next;\r\n  var input;\r\n  var tmpDict;\r\n\r\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\r\n    return Z_STREAM_ERROR;\r\n  }\r\n\r\n  s = strm.state;\r\n  wrap = s.wrap;\r\n\r\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\r\n    return Z_STREAM_ERROR;\r\n  }\r\n\r\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\r\n  if (wrap === 1) {\r\n    /* adler32(strm->adler, dictionary, dictLength); */\r\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\r\n  }\r\n\r\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\r\n\r\n  /* if dictionary would fill window, just replace the history */\r\n  if (dictLength >= s.w_size) {\r\n    if (wrap === 0) {            /* already empty otherwise */\r\n      /*** CLEAR_HASH(s); ***/\r\n      zero(s.head); // Fill with NIL (= 0);\r\n      s.strstart = 0;\r\n      s.block_start = 0;\r\n      s.insert = 0;\r\n    }\r\n    /* use the tail */\r\n    // dictionary = dictionary.slice(dictLength - s.w_size);\r\n    tmpDict = new utils.Buf8(s.w_size);\r\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\r\n    dictionary = tmpDict;\r\n    dictLength = s.w_size;\r\n  }\r\n  /* insert dictionary into window and hash */\r\n  avail = strm.avail_in;\r\n  next = strm.next_in;\r\n  input = strm.input;\r\n  strm.avail_in = dictLength;\r\n  strm.next_in = 0;\r\n  strm.input = dictionary;\r\n  fill_window(s);\r\n  while (s.lookahead >= MIN_MATCH) {\r\n    str = s.strstart;\r\n    n = s.lookahead - (MIN_MATCH - 1);\r\n    do {\r\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\r\n\r\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\r\n\r\n      s.head[s.ins_h] = str;\r\n      str++;\r\n    } while (--n);\r\n    s.strstart = str;\r\n    s.lookahead = MIN_MATCH - 1;\r\n    fill_window(s);\r\n  }\r\n  s.strstart += s.lookahead;\r\n  s.block_start = s.strstart;\r\n  s.insert = s.lookahead;\r\n  s.lookahead = 0;\r\n  s.match_length = s.prev_length = MIN_MATCH - 1;\r\n  s.match_available = 0;\r\n  strm.next_in = next;\r\n  strm.input = input;\r\n  strm.avail_in = avail;\r\n  s.wrap = wrap;\r\n  return Z_OK;\r\n}\r\n\r\n\r\nexport { deflateInit, deflateInit2, deflateReset, deflateResetKeep, deflateSetHeader, deflate, deflateEnd, deflateSetDictionary };\r\nexport var deflateInfo = 'pako deflate (from Nodeca project)';\r\n\r\n/* Not implemented\r\nexports.deflateBound = deflateBound;\r\nexports.deflateCopy = deflateCopy;\r\nexports.deflateParams = deflateParams;\r\nexports.deflatePending = deflatePending;\r\nexports.deflatePrime = deflatePrime;\r\nexports.deflateTune = deflateTune;\r\n*/\r\n"]}