{"version":3,"sources":["hextile.js"],"names":["HextileDecoder","_tiles","_lastsubencoding","_tileBuffer","Uint8Array","x","y","width","height","sock","display","depth","_tilesX","Math","ceil","_tilesY","_totalTiles","bytes","rQwait","rQ","rQi","subencoding","Error","currTile","tileX","tileY","floor","tx","ty","tw","min","th","subrects","Log","Debug","fillRect","_background","pixels","i","blitImage","_foreground","_startTile","s","color","xy","sx","sy","wh","sw","sh","_subTile","_finishTile","_tileX","_tileY","_tileW","_tileH","red","green","blue","data","w","h","xend","yend","j","p"],"mappings":"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","sourcesContent":["/*\r\n * noVNC: HTML5 VNC client\r\n * Copyright (C) 2019 The noVNC Authors\r\n * Licensed under MPL 2.0 (see LICENSE.txt)\r\n *\r\n * See README.md for usage and integration instructions.\r\n *\r\n */\r\n\r\nimport * as Log from '../util/logging.js';\r\n\r\nexport default class HextileDecoder {\r\n    constructor() {\r\n        this._tiles = 0;\r\n        this._lastsubencoding = 0;\r\n        this._tileBuffer = new Uint8Array(16 * 16 * 4);\r\n    }\r\n\r\n    decodeRect(x, y, width, height, sock, display, depth) {\r\n        if (this._tiles === 0) {\r\n            this._tilesX = Math.ceil(width / 16);\r\n            this._tilesY = Math.ceil(height / 16);\r\n            this._totalTiles = this._tilesX * this._tilesY;\r\n            this._tiles = this._totalTiles;\r\n        }\r\n\r\n        while (this._tiles > 0) {\r\n            let bytes = 1;\r\n\r\n            if (sock.rQwait(\"HEXTILE\", bytes)) {\r\n                return false;\r\n            }\r\n\r\n            let rQ = sock.rQ;\r\n            let rQi = sock.rQi;\r\n\r\n            let subencoding = rQ[rQi];  // Peek\r\n            if (subencoding > 30) {  // Raw\r\n                throw new Error(\"Illegal hextile subencoding (subencoding: \" +\r\n                            subencoding + \")\");\r\n            }\r\n\r\n            const currTile = this._totalTiles - this._tiles;\r\n            const tileX = currTile % this._tilesX;\r\n            const tileY = Math.floor(currTile / this._tilesX);\r\n            const tx = x + tileX * 16;\r\n            const ty = y + tileY * 16;\r\n            const tw = Math.min(16, (x + width) - tx);\r\n            const th = Math.min(16, (y + height) - ty);\r\n\r\n            // Figure out how much we are expecting\r\n            if (subencoding & 0x01) {  // Raw\r\n                bytes += tw * th * 4;\r\n            } else {\r\n                if (subencoding & 0x02) {  // Background\r\n                    bytes += 4;\r\n                }\r\n                if (subencoding & 0x04) {  // Foreground\r\n                    bytes += 4;\r\n                }\r\n                if (subencoding & 0x08) {  // AnySubrects\r\n                    bytes++;  // Since we aren't shifting it off\r\n\r\n                    if (sock.rQwait(\"HEXTILE\", bytes)) {\r\n                        return false;\r\n                    }\r\n\r\n                    let subrects = rQ[rQi + bytes - 1];  // Peek\r\n                    if (subencoding & 0x10) {  // SubrectsColoured\r\n                        bytes += subrects * (4 + 2);\r\n                    } else {\r\n                        bytes += subrects * 2;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (sock.rQwait(\"HEXTILE\", bytes)) {\r\n                return false;\r\n            }\r\n\r\n            // We know the encoding and have a whole tile\r\n            rQi++;\r\n            if (subencoding === 0) {\r\n                if (this._lastsubencoding & 0x01) {\r\n                    // Weird: ignore blanks are RAW\r\n                    Log.Debug(\"     Ignoring blank after RAW\");\r\n                } else {\r\n                    display.fillRect(tx, ty, tw, th, this._background);\r\n                }\r\n            } else if (subencoding & 0x01) {  // Raw\r\n                let pixels = tw * th;\r\n                // Max sure the image is fully opaque\r\n                for (let i = 0;i <  pixels;i++) {\r\n                    rQ[rQi + i * 4 + 3] = 255;\r\n                }\r\n                display.blitImage(tx, ty, tw, th, rQ, rQi);\r\n                rQi += bytes - 1;\r\n            } else {\r\n                if (subencoding & 0x02) {  // Background\r\n                    this._background = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];\r\n                    rQi += 4;\r\n                }\r\n                if (subencoding & 0x04) {  // Foreground\r\n                    this._foreground = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];\r\n                    rQi += 4;\r\n                }\r\n\r\n                this._startTile(tx, ty, tw, th, this._background);\r\n                if (subencoding & 0x08) {  // AnySubrects\r\n                    let subrects = rQ[rQi];\r\n                    rQi++;\r\n\r\n                    for (let s = 0; s < subrects; s++) {\r\n                        let color;\r\n                        if (subencoding & 0x10) {  // SubrectsColoured\r\n                            color = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];\r\n                            rQi += 4;\r\n                        } else {\r\n                            color = this._foreground;\r\n                        }\r\n                        const xy = rQ[rQi];\r\n                        rQi++;\r\n                        const sx = (xy >> 4);\r\n                        const sy = (xy & 0x0f);\r\n\r\n                        const wh = rQ[rQi];\r\n                        rQi++;\r\n                        const sw = (wh >> 4) + 1;\r\n                        const sh = (wh & 0x0f) + 1;\r\n\r\n                        this._subTile(sx, sy, sw, sh, color);\r\n                    }\r\n                }\r\n                this._finishTile(display);\r\n            }\r\n            sock.rQi = rQi;\r\n            this._lastsubencoding = subencoding;\r\n            this._tiles--;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // start updating a tile\r\n    _startTile(x, y, width, height, color) {\r\n        this._tileX = x;\r\n        this._tileY = y;\r\n        this._tileW = width;\r\n        this._tileH = height;\r\n\r\n        const red = color[0];\r\n        const green = color[1];\r\n        const blue = color[2];\r\n\r\n        const data = this._tileBuffer;\r\n        for (let i = 0; i < width * height * 4; i += 4) {\r\n            data[i]     = red;\r\n            data[i + 1] = green;\r\n            data[i + 2] = blue;\r\n            data[i + 3] = 255;\r\n        }\r\n    }\r\n\r\n    // update sub-rectangle of the current tile\r\n    _subTile(x, y, w, h, color) {\r\n        const red = color[0];\r\n        const green = color[1];\r\n        const blue = color[2];\r\n        const xend = x + w;\r\n        const yend = y + h;\r\n\r\n        const data = this._tileBuffer;\r\n        const width = this._tileW;\r\n        for (let j = y; j < yend; j++) {\r\n            for (let i = x; i < xend; i++) {\r\n                const p = (i + (j * width)) * 4;\r\n                data[p]     = red;\r\n                data[p + 1] = green;\r\n                data[p + 2] = blue;\r\n                data[p + 3] = 255;\r\n            }\r\n        }\r\n    }\r\n\r\n    // draw the current tile to the screen\r\n    _finishTile(display) {\r\n        display.blitImage(this._tileX, this._tileY,\r\n                          this._tileW, this._tileH,\r\n                          this._tileBuffer, 0);\r\n    }\r\n}\r\n"]}